<?php
// $Id$

/**
 * @file
 * OAuth Connector module
 */

//TODO: Make something with the name - do we really want to and can we really import them?
//TODO: Trim URL of any trailing slashes/spaces
//TODO: Add support for XML
//TODO: Save the link between a provider specification and a consumer key in a separate table?
//      Perhaps extend OAuth Commons GUI for that?
//TODO: Add timeouts for when an API is down?
//TODO: Add rules support - actions etc.
//TODO: Refactor - hook_connector() should return multiple connectors -
//      not hide everything behide one connector
//TODO: Add features support - should be possible to export as part of a feature
//TODO: Make it possible to specify mapping resources relative to the base url as well

/* ************************************************************************* *
 * THEME FUNCTIONS
 * ************************************************************************* */

/**
 * Implementation of hook_theme().
 */
function oauthconnector_theme() {
  $theme = array(
    'oauthconnector_button' => array(
      'arguments' => array(),
    ),
  );

  return $theme;
}

/**
 * Theme function for the button
 */
function theme_oauthconnector_button() {
  return drupal_get_form('oauthconnector_button_form');
}


/* ************************************************************************* *
 * DRUPAL HOOKS
 * ************************************************************************* */

/**
 * Implementation of hook_connector().
 */
function oauthconnector_connector() {
  $items = array();

  //TODO: Iterate through all of the oauth connectors here instead.
  //      They should appear as invidiual connectors to Connector
  $items['oauthconnector'] = array(
    'button callback'      => '_oauthconnector_button',
    'information callback' => '_oauthconnector_info',
    'avatar callback'      => '_oauthconnector_avatar',
  );

  return $items;
}


/**
 * Implementation of hook_menu().
 */
function oauthconnector_menu() {
  $items = array();

  $base = array(
    'access arguments' => array('administer oauth connector'),
    'file'             => 'oauthconnector.admin.inc',
  );

  $items['admin/build/oauthconnector'] = array(
    'title'          => 'OAuth Connector',
    'description'    => 'Add, edit and remove OAuth Connector providers from the system.',
    'page callback'  => 'oauthconnector_list_provider',
  ) + $base;
  $items['admin/build/oauthconnector/list'] = array(
    'title'          => 'List',
    'page callback'  => 'oauthconnector_list_provider',
    'type'           => MENU_DEFAULT_LOCAL_TASK,
    'weight'         => -10,
  ) + $base;
  $items['admin/build/oauthconnector/add'] = array(
    'title'          => 'Add provider',
    'page callback'  => 'oauthconnector_add_provider',
    'type'           => MENU_LOCAL_TASK,
  ) + $base;
  $items['admin/build/oauthconnector/%oauthconnector_provider/edit'] = array(
    'title'          => 'Edit provider',
    'page callback'  => 'oauthconnector_edit_provider',
    'page arguments' => array(3),
    'type'           => MENU_LOCAL_TASK,
  ) + $base;
  $items['admin/build/oauthconnector/%oauthconnector_provider/export'] = array(
    'title'          => 'Export provider',
    'page callback'  => 'drupal_get_form',
    'page arguments' => array('oauthconnector_export_provider', 3),
    'type'           => MENU_LOCAL_TASK,
  ) + $base;
  $items['admin/build/oauthconnector/%oauthconnector_provider/delete'] = array(
    'title'          => 'Delete provider',
    'page callback'  => 'drupal_get_form',
    'page arguments' => array('oauthconnector_delete_confirm_provider', 3),
    'type'           => MENU_CALLBACK,
  ) + $base;
  $items['admin/build/oauthconnector/%oauthconnector_provider/disable'] = array(
    'page callback'  => 'oauthconnector_disable_provider',
    'page arguments' => array(3),
    'type'           => MENU_CALLBACK,
  ) + $base;
  $items['admin/build/oauthconnector/%oauthconnector_provider/enable'] = array(
    'page callback'  => 'oauthconnector_enable_provider',
    'page arguments' => array(3),
    'type'           => MENU_CALLBACK,
  ) + $base;

  return $items;
}

/**
 * Implementation of hook_oauth_common_authorized().
 */
function oauthconnector_oauth_common_authorized($consumer_token, $access_token, $request_token) {
  global $user;

  if ($_SESSION['oauthconnector_request_key'] == $request_token->key) {
    // Delete the access token, we only need it once.
    unset($_SESSION['oauthconnector_request_key']);

    $providers = oauthconnector_provider_load_all();
    foreach ($providers as $provider) {
      if ($provider->consumer_key == $consumer_token->key) {
        //TODO: Optionally remove the access token - if the provider was only used for log in
        //      and not for fetching any data then we don't need the access token anymore.
        //$access_token->delete();
        $external_uid = _oauthconnector_fetch_field('uid', $provider, $access_token, $consumer_token);
        if (!empty($external_uid)) {
          if (_connector_log_in('oauthconnector', $provider->name . '__' . $external_uid)) {
            //TODO: Remove old access tokens?
            //TODO: Don't link token to local UID - link to external UID
            $access_token->uid = $user->uid;
            $access_token->write(TRUE);
            //TODO: Include this in _connector_log_in()?
            $info = _connector_information_fetch($user->uid, array('real name' => TRUE));
            if (empty($info['real name'])) {
              _connector_information_update($user->uid, array('real name' => TRUE));
            }
          }
        }
        else {
          //TODO: Add error message
        }
        break;
      }
    }
  }
}


/* ************************************************************************* *
 * CTOOLS INTEGRATION
 * ************************************************************************* */

/**
 * Create a new provider with defaults appropriately set from schema.
 *
 * @return stdClass
 *   A provider configuration initialized with the default values.
 */
function oauthconnector_provider_new() {
  ctools_include('export');
  return ctools_export_new_object('oauthconnector_provider');
}

/**
 * Load a single provider.
 *
 * @param string $name
 *   The name of the provider.
 * @return stdClass
 *   The provider configuration.
 */
function oauthconnector_provider_load($name) {
  ctools_include('export');
  $result = ctools_export_load_object('oauthconnector_provider', 'names', array($name));
  //TODO: Load some stuff from OAuth Common here as well? Perhaps the entire consumer?
  if (isset($result[$name])) {
    return $result[$name];
  }
  else {
    return FALSE;
  }
}

//TODO: Add method for loading only "active" oauthconnectors? Eg. those with a consumer_key? Or make it impossible to enable a provider without also supplying a consumer_key and secret?

/**
 * Load all providers.
 *
 * @return array
 *   Array of provider configuration objects keyed by provider names.
 */
function oauthconnector_provider_load_all() {
  ctools_include('export');
  return ctools_export_load_object('oauthconnector_provider');
}

/**
 * Saves a provider in the database.
 *
 * @return void
 */
function oauthconnector_provider_save($provider) {
  $update = (isset($provider->pid)) ? array('pid') : array();

  //TODO: Update the OAuth Common as well?
  if (!empty($provider->consumer_key) && !empty($provider->consumer_secret)) {
    $consumer = DrupalOAuthConsumer::load($provider->consumer_key, FALSE);
    if ($consumer) {
      $consumer->secret = $provider->consumer_secret;
      $consumer->configuration['provider_url'] = $provider->url;
      $consumer->configuration['signature_method'] = $provider->consumer_advanced['signature method'];
      $consumer->configuration['authentication_realm'] = $provider->consumer_advanced['authentication realm'];
      $consumer->configuration['access_endpoint'] = $provider->consumer_advanced['access token endpoint'];
      $consumer->write(TRUE);
    }
    else {
      $consumer = new DrupalOAuthConsumer($provider->consumer_key, $provider->consumer_secret, 'oob', FALSE, array(
        'configuration' => array(
          'provider_url' => $provider->url,
        )
      ));
      $consumer->write();
    }

  }

  drupal_write_record('oauthconnector_provider', $provider, $update);
}

/**
 * Remove a provider.
 *
 * @return void
 */
function oauthconnector_provider_delete($provider) {
  //TODO: Also delete data from OAuth Common
  db_query("DELETE FROM {oauthconnector_provider} WHERE name = '%s' AND pid = %d", $provider->name, $provider->pid);
}

/**
 * Export a provider.
 *
 * @return string
 */
function oauthconnector_provider_export($provider, $indent = '') {
  //TODO: Try to make the exported provider disabled as default?
  ctools_include('export');
  $output = ctools_export_object('oauthconnector_provider', $provider, $indent);
  return $output;
}

/**
 * Lists all available providers.
 *
 * @return array
 */
function oauthconnector_provider_list() {
  $return = array();
  $providers = oauthconnector_provider_load_all();
  foreach ($providers as $provider) {
    $return[$provider->name] = $provider->title;
  }
  return $return;
}


/* ************************************************************************* *
 * OAUTH INTEGRATION
 * ************************************************************************* */

/**
 * Information callback
 */
function _oauthconnector_info($cid, $types, $uid) {
  if (!empty($types) && empty($types['real name'])) {
    return FALSE;
  }

  $info = FALSE;

  $cid = explode('__', $cid, 2);
  $provider = oauthconnector_provider_load($cid[0]);

  if (!empty($provider->mapping['fields']['real name']['resource'])) {
    $result = db_query("SELECT * FROM {oauth_common_token} WHERE uid = %d AND consumer_key = '%s' AND type = 'access' AND provider_token = 0", array(
      ':uid' => $uid,
      ':consumer_key' => $provider->consumer_key,
    ));
    $token = DrupalOAuthToken::fromResult($result);

    $real_name = _oauthconnector_fetch_field('real name', $provider, $token);
    if ($real_name) {
      //TODO: Some better error handling?
      $info = array('real name' => $real_name);
    }
  }

  return $info;
}

/**
 * Information callback
 */
function _oauthconnector_avatar($cid, $uid) {
  $info = FALSE;

  $cid = explode('__', $cid, 2);
  $provider = oauthconnector_provider_load($cid[0]);

  if (!empty($provider->mapping['fields']['avatar']['resource'])) {
    $result = db_query("SELECT * FROM {oauth_common_token} WHERE uid = %d AND consumer_key = '%s' AND type = 'access' AND provider_token = 0", array(
      ':uid' => $uid,
      ':consumer_key' => $provider->consumer_key,
    ));
    $token = DrupalOAuthToken::fromResult($result);

    $info = _oauthconnector_fetch_field('avatar', $provider, $token);
    //TODO: Some better error handling?
    if (empty($info)) {
      $info = FALSE;
    }
  }

  return $info;
}

function _oauthconnector_button() {
  return array(
    'title' => theme('oauthconnector_button'),
    'html'  => TRUE,
  );
}

function oauthconnector_button_form(&$form_state) {
  $form = array();
  $providers = oauthconnector_provider_load_all();
  foreach ($providers as $provider) {
    if ($provider->consumer_key) {
      $form['login_' . $provider->name] = array(
        '#type'  => 'submit',
        '#value' => t('Connect with !title', array('!title' => $provider->title)),
        'provider' => array(
          '#type'  => 'value',
          '#value' => $provider,
        ),
      );
    }
  }
  return $form;
}

function oauthconnector_button_form_submit($form, &$form_state) {
  //TODO: Move some of the contens of this function to oauth_common_get_request_token()?

  $provider = $form_state['clicked_button']['provider']['#value'];
  $callback_url = url('oauth/authorized', array('absolute' => TRUE));

  $consumer_token = DrupalOAuthConsumer::load($provider->consumer_key, FALSE);
  $sig_method = DrupalOAuthClient::signatureMethod(substr(strtolower($provider->consumer_advanced['signature method']), 5));

  $client = new DrupalOAuthClient($consumer_token, NULL, $sig_method); //TODO: Customize signaturemethod here
  $request_token = $client->getRequestToken($provider->consumer_advanced['request token endpoint'], array(), $provider->consumer_advanced['authentication realm'], FALSE, $callback_url); //TODO: Add request_endpoint here?
  $request_token->write();

  $_SESSION['oauthconnector_request_key'] = $request_token->key;
  $auth_url = $client->getAuthorizationUrl($callback_url, $provider->consumer_advanced['authorization endpoint']); //TODO: Add some endpoints here?

  drupal_goto($auth_url);
}

//TODO: Add caching of requests?
function _oauthconnector_fetch_field($field, $provider, $access_token, $consumer_token = NULL) {
  static $cache = array();

  $field = $provider->mapping['fields'][$field];

  if (!isset($cache[$access_token->token_key])) {
    $cache[$access_token->token_key] = array();
  }
  if (!isset($cache[$access_token->token_key][$field['method post']])) {
    $cache[$access_token->token_key][$field['method post']] = array();
  }

  if (!isset($cache[$access_token->token_key][$field['method post']][$field['resource']])) {
    // Load the consumer token if needed
    if (!$consumer_token) {
      $consumer_token = DrupalOAuthConsumer::load($provider->consumer_key, FALSE);
    }

    // Set up the rest client
    $sig_method = DrupalOAuthClient::signatureMethod(substr(strtolower($provider->consumer_advanced['signature method']), 5));
    $realm = empty($provider->consumer_advanced['authentication realm']) ? NULL : $provider->consumer_advanced['authentication realm'];
    $auth = new HttpClientOAuth($consumer_token, $access_token, $sig_method, TRUE, TRUE, $realm);

    switch ($provider->mapping['format']) {
      case 'xml':
        $formatter = new HttpClientXMLFormatter();
        break;
      case 'php':
        $formatter = new HttpClientBaseFormatter(HttpClientBaseFormatter::FORMAT_PHP);
        break;
      default:
        $formatter = new HttpClientBaseFormatter(HttpClientBaseFormatter::FORMAT_JSON);
        break;
    }
    $client = new HttpClient($auth, $formatter);

    // Fetch the external user
    $request_method = empty($field['method post']) ? 'get' : 'post';
    try {
      $info = (array)$client->{$request_method}($field['resource']);
      $cache[$access_token->token_key][$field['method post']][$field['resource']] = $info;
    } catch (Exception $e) {
      //TODO: Change to watchdog?
      drupal_set_message(t('Failed to fetch user info for login: @message', array(
        '@message' => $e->getMessage(),
      )), 'error');
    }
  }
  else {
    $info = $cache[$access_token->token_key][$field['method post']][$field['resource']];
  }

  $response = FALSE;

  if (!empty($info)) {
    if (!empty($field['querypath']) && module_exists('querypath')) {
      //TODO: Perhaps cache this QueryPath object as well?
      $response = _oauthconnector_object_to_qp(qp('<?xml version="1.0"?><reponse/>'), $info)->find($field['field'])->eq(0)->text();
    }
    elseif (!empty($info[$field['field']])) {
      $response = $info[$field['field']];
    }
  }

  return $response;
}

function _oauthconnector_object_to_qp($qp, $values) {
  foreach ($values as $key => $val) {
    if (is_object($val)) {
      $val = get_object_vars($val);
    }
    $key = check_plain(str_replace(' ', '_', $key));
    if (is_array($val)) {
      $qp->append(_oauthconnector_object_to_qp(qp('<?xml version="1.0"?><' . $key . '/>'), $val));
    }
    else {
      $qp->append(qp('<?xml version="1.0"?><' . $key . '>' . check_plain($val) . '</' . $key . '>'));
    }
  }
  return $qp;
}